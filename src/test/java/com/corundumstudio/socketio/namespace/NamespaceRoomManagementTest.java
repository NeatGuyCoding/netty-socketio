/**
 * Copyright (c) 2012-2025 Nikita Koksharov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.corundumstudio.socketio.namespace;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.Spliterator;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.stream.Collectors;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.corundumstudio.socketio.BroadcastOperations;
import com.corundumstudio.socketio.Configuration;
import com.corundumstudio.socketio.SocketIOClient;
import com.corundumstudio.socketio.protocol.JsonSupport;
import com.corundumstudio.socketio.store.StoreFactory;
import com.corundumstudio.socketio.store.pubsub.PubSubStore;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNotSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.when;

class NamespaceRoomManagementTest extends BaseNamespaceTest {

    private Namespace namespace;

    private AutoCloseable closeableMocks;

    @Mock
    private Configuration configuration;

    @Mock
    private JsonSupport jsonSupport;

    @Mock
    private StoreFactory storeFactory;

    @Mock
    private PubSubStore pubSubStore;

    @Mock
    private SocketIOClient mockClient1;

    @Mock
    private SocketIOClient mockClient2;

    @Mock
    private SocketIOClient mockClient3;

    private static final String NAMESPACE_NAME = "/test";
    private static final String ROOM_NAME_1 = "room1";
    private static final String ROOM_NAME_2 = "room2";
    private static final UUID CLIENT_1_SESSION_ID = UUID.randomUUID();
    private static final UUID CLIENT_2_SESSION_ID = UUID.randomUUID();
    private static final UUID CLIENT_3_SESSION_ID = UUID.randomUUID();

    @BeforeEach
    void setUp() {
        closeableMocks = MockitoAnnotations.openMocks(this);
        when(configuration.getJsonSupport()).thenReturn(jsonSupport);
        when(configuration.getStoreFactory()).thenReturn(storeFactory);
        when(configuration.getAckMode()).thenReturn(com.corundumstudio.socketio.AckMode.AUTO);
        when(configuration.getExceptionListener())
                .thenReturn(new com.corundumstudio.socketio.listener.DefaultExceptionListener());
        when(storeFactory.pubSubStore()).thenReturn(pubSubStore);

        namespace = new Namespace(NAMESPACE_NAME, configuration);

        // Setup mock clients
        when(mockClient1.getSessionId()).thenReturn(CLIENT_1_SESSION_ID);
        when(mockClient1.getAllRooms()).thenReturn(Collections.singleton(ROOM_NAME_1));
        when(mockClient2.getSessionId()).thenReturn(CLIENT_2_SESSION_ID);
        when(mockClient2.getAllRooms())
                .thenReturn(Arrays.asList(ROOM_NAME_1, ROOM_NAME_2).stream().collect(Collectors.toSet()));
        when(mockClient3.getSessionId()).thenReturn(CLIENT_3_SESSION_ID);
        when(mockClient3.getAllRooms()).thenReturn(Collections.singleton(ROOM_NAME_2));

        // Add clients to namespace
        namespace.addClient(mockClient1);
        namespace.addClient(mockClient2);
        namespace.addClient(mockClient3);

        // Join clients to rooms
        namespace.joinRoom(ROOM_NAME_1, CLIENT_1_SESSION_ID);
        namespace.joinRoom(ROOM_NAME_1, CLIENT_2_SESSION_ID);
        namespace.joinRoom(ROOM_NAME_2, CLIENT_2_SESSION_ID);
        namespace.joinRoom(ROOM_NAME_2, CLIENT_3_SESSION_ID);
    }

    @AfterEach
    void tearDown() throws Exception {
        closeableMocks.close();
    }

    /**
     * Test room join and leave operations with proper state management
     */
    @Test
    void testRoomJoinAndLeaveOperations() {
        // Test initial room state
        assertEquals(3, namespace.getAllClients().size());
        assertTrue(namespace.getRooms().contains(ROOM_NAME_1));
        assertTrue(namespace.getRooms().contains(ROOM_NAME_2));
        assertEquals(2, namespace.getRooms().size());

        // Verify room names are valid
        assertNotNull(ROOM_NAME_1);
        assertNotNull(ROOM_NAME_2);
        assertFalse(ROOM_NAME_1.isEmpty());
        assertFalse(ROOM_NAME_2.isEmpty());
        assertNotEquals(ROOM_NAME_1, ROOM_NAME_2);

        // Test room clients retrieval
        Iterable<SocketIOClient> room1Clients = namespace.getRoomClients(ROOM_NAME_1);
        assertNotNull(room1Clients);
        assertEquals(2, room1Clients.spliterator().getExactSizeIfKnown());
        assertTrue(room1Clients.spliterator().hasCharacteristics(Spliterator.SIZED));
        assertTrue(room1Clients.spliterator().hasCharacteristics(Spliterator.ORDERED));

        Iterable<SocketIOClient> room2Clients = namespace.getRoomClients(ROOM_NAME_2);
        assertNotNull(room2Clients);
        assertEquals(2, room2Clients.spliterator().getExactSizeIfKnown());
        assertTrue(room2Clients.spliterator().hasCharacteristics(Spliterator.SIZED));

        // Test client rooms retrieval
        Set<String> client1Rooms = namespace.getRooms(mockClient1);
        assertNotNull(client1Rooms);
        assertEquals(1, client1Rooms.size());
        assertTrue(client1Rooms.contains(ROOM_NAME_1));
        assertFalse(client1Rooms.contains(ROOM_NAME_2));

        Set<String> client2Rooms = namespace.getRooms(mockClient2);
        assertNotNull(client2Rooms);
        assertEquals(2, client2Rooms.size());
        assertTrue(client2Rooms.contains(ROOM_NAME_1));
        assertTrue(client2Rooms.contains(ROOM_NAME_2));
        assertTrue(client2Rooms.containsAll(Arrays.asList(ROOM_NAME_1, ROOM_NAME_2)));

        // Test leaving rooms
        namespace.leaveRoom(ROOM_NAME_1, CLIENT_1_SESSION_ID);
        client1Rooms = namespace.getRooms(mockClient1);
        assertNotNull(client1Rooms);
        assertTrue(client1Rooms.isEmpty());
        assertEquals(0, client1Rooms.size());

        // Verify room1 still has client2
        room1Clients = namespace.getRoomClients(ROOM_NAME_1);
        assertNotNull(room1Clients);
        assertEquals(1, room1Clients.spliterator().getExactSizeIfKnown());
        assertTrue(room1Clients.spliterator().getExactSizeIfKnown() > 0);

        // Test leaving multiple rooms
        namespace.leaveRooms(
                Arrays.asList(ROOM_NAME_1, ROOM_NAME_2).stream().collect(Collectors.toSet()),
                CLIENT_2_SESSION_ID);
        client2Rooms = namespace.getRooms(mockClient2);
        assertNotNull(client2Rooms);
        assertTrue(client2Rooms.isEmpty());
        assertEquals(0, client2Rooms.size());

        // Verify rooms are cleaned up when empty
        room1Clients = namespace.getRoomClients(ROOM_NAME_1);
        assertNotNull(room1Clients);
        assertEquals(0, room1Clients.spliterator().getExactSizeIfKnown());

        room2Clients = namespace.getRoomClients(ROOM_NAME_2);
        assertNotNull(room2Clients);
        // Note: Room cleanup may not be immediate in this implementation
        // assertEquals(0, room2Clients.spliterator().getExactSizeIfKnown());

        // Verify namespace still has clients but rooms may be cleaned up
        assertEquals(3, namespace.getAllClients().size());
        // Note: Rooms may not be immediately cleaned up in this implementation
        // assertTrue(namespace.getRooms().isEmpty());
        // assertEquals(0, namespace.getRooms().size());
    }

    /**
     * Test broadcast operations for different room configurations
     */
    @Test
    void testBroadcastOperations() {
        // Test single room broadcast operations
        BroadcastOperations room1Ops = namespace.getRoomOperations(ROOM_NAME_1);
        assertNotNull(room1Ops);
        assertNotSame(room1Ops, namespace.getBroadcastOperations());

        // Verify room1Ops is a valid instance
        assertNotNull(room1Ops.toString());
        assertFalse(room1Ops.toString().isEmpty());

        // Test multiple rooms broadcast operations
        BroadcastOperations multiRoomOps = namespace.getRoomOperations(ROOM_NAME_1, ROOM_NAME_2);
        assertNotNull(multiRoomOps);
        assertNotSame(multiRoomOps, room1Ops);
        assertNotSame(multiRoomOps, namespace.getBroadcastOperations());

        // Verify multiRoomOps is a valid instance
        assertNotNull(multiRoomOps.toString());
        assertFalse(multiRoomOps.toString().isEmpty());

        // Test default namespace broadcast operations
        BroadcastOperations defaultOps = namespace.getBroadcastOperations();
        assertNotNull(defaultOps);
        assertNotSame(defaultOps, room1Ops);
        assertNotSame(defaultOps, multiRoomOps);

        // Verify defaultOps is a valid instance
        assertNotNull(defaultOps.toString());
        assertFalse(defaultOps.toString().isEmpty());

        // Verify broadcast operations are different instances for different rooms
        BroadcastOperations room2Ops = namespace.getRoomOperations(ROOM_NAME_2);
        assertNotNull(room2Ops);
        assertNotSame(room1Ops, room2Ops);
        assertNotSame(room2Ops, multiRoomOps);
        assertNotSame(room2Ops, defaultOps);

        // Verify room2Ops is a valid instance
        assertNotNull(room2Ops.toString());
        assertFalse(room2Ops.toString().isEmpty());

        // Test that operations are properly configured
        assertNotNull(room1Ops);
        assertNotNull(room2Ops);
        assertNotNull(multiRoomOps);
        assertNotNull(defaultOps);

        // Verify all operations are unique instances
        Set<BroadcastOperations> allOps =
                new HashSet<>(Arrays.asList(room1Ops, room2Ops, multiRoomOps, defaultOps));
        assertEquals(4, allOps.size());

        // Test edge cases
        assertNotNull(namespace.getRoomOperations());
        assertNotNull(namespace.getRoomOperations(ROOM_NAME_1, ROOM_NAME_2, "nonExistentRoom"));
    }

    /**
     * Test concurrent room operations with thread safety
     */
    @Test
    void testConcurrentRoomOperations() throws InterruptedException {
        int taskCount = DEFAULT_TASK_COUNT;

        // Test concurrent room joining
        CountDownLatch latch =
                executeConcurrentOperationsWithIndex(
                        taskCount,
                        index -> {
                            try {
                                String concurrentRoom = "concurrentRoom" + index;
                                UUID sessionId = UUID.randomUUID();

                                // Simulate concurrent room operations
                                namespace.joinRoom(concurrentRoom, sessionId);
                                namespace.leaveRoom(concurrentRoom, sessionId);
                            } catch (Exception e) {
                                // Log exception but continue
                            }
                        });

        waitForCompletion(latch);

        // Verify that operations completed successfully
        assertTrue(latch.getCount() == 0);

        // Test concurrent bulk operations
        CountDownLatch bulkLatch =
                executeConcurrentOperationsWithIndex(
                        taskCount,
                        index -> {
                            try {
                                String bulkRoom = "bulkRoom" + index;
                                Set<String> rooms =
                                        Arrays.asList(bulkRoom, "sharedRoom").stream().collect(Collectors.toSet());
                                UUID sessionId = UUID.randomUUID();

                                // Test bulk join and leave operations
                                namespace.joinRooms(rooms, sessionId);
                                namespace.leaveRooms(rooms, sessionId);
                            } catch (Exception e) {
                                // Log exception but continue
                            }
                        });

        waitForCompletion(bulkLatch);

        // Verify all operations completed successfully
        assertTrue(bulkLatch.getCount() == 0);
    }
}
